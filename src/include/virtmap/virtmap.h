#pragma once
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/*                  Copyright (c) (2021 - 2024) Nicolaus Starke               */
/*                  https://github.com/nic-starke/neon_samurai                */
/*                         SPDX-License-Identifier: MIT                       */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Documentation ~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Includes ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

#include "core/core_types.h"
#include "protocol/protocol.h"

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Defines ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Extern ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Types ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

typedef struct virtmap_s {
	/**
	 * @brief The lower and upper range determine the numerical values that will
	 * be generated by the virtual encoder as it is rotated.
	 *
	 * E.g if the lower value is 1000 and the upper value is 5000, then the
	 * virtual encoder will output the value 1000 at the position.start point
	 * (see position struct below) and the value 5000 at the position.stop point.
	 *
	 * Every intermediate point is linearly interpolated, so halfway between
	 * start and stop would output a value of  3000 in this  example.
	 *
	 * Note that if the lower value is greater than the upper value then
	 * the generated values will be in reverse order, i.e the output
	 * will start at 5000 and reduce as the encoder is rotated clockwise.
	 */
	struct {
		i32 lower;
		i32 upper;
	} range;

	/**
	 * @brief The start and stop position are the absolute values determining
	 * where the virtual encoder begins and ends on the physical encoder rotation.
	 * E.g if the start value is 0% and the stop value is 50% then the virtual
	 * encoder will only operate from 0 degrees to 180 degrees (midpoint) of the
	 * physical encoder.
	 *
	 * Note that the start and stop values are not percentages, they are a 16-bit
	 * value. To calculate percentages use the appropriate defines for
	 * min/max encoder value.
	 */
	struct {
		u16 start;
		u16 stop;
	} position;

	proto_cfg_s				proto;
	struct virtmap_s* next;
} virtmap_s;

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Prototypes ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

/**
 * @brief Initialise a virtual parameter mapping.
 *
 * @param vmap Pointer to virtual parameter.
 * @return int 0 on success, 0! on failure.
 */
int virtmap_init(virtmap_s* vmap);
