#pragma once
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/*                  Copyright (c) (2021 - 2024) Nicolaus Starke               */
/*                  https://github.com/nic-starke/neon_samurai                */
/*                         SPDX-License-Identifier: MIT                       */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Documentation ~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Includes ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

#include "core/core_types.h"
#include "encoder/encoder_quadrature.h"

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Defines ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Extern ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Types ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

typedef struct vencoder_ctx_s {
	u8 enabled; // Bool, 0 - off, 1 - on

	/**
	 * @brief The lower and upper range determine the numerical values that will
	 * be generated by the virtual encoder as it is rotated.
	 *
	 * E.g if the lower value is 1000 and the upper value is 5000, then the
	 * virtual encoder will output the value 1000 at the position.start point
	 * (see position struct below) and the value 5000 at the position.stop point.
	 *
	 * Every intermediate point is linearly interpolated, so halfway between
	 * start and stop would output a value of  3000 in this  example.
	 *
	 * Note that if the lower value is greater than the upper value then
	 * the generated values will be in reverse order, i.e the output
	 * will start at 5000 and reduce as the encoder is rotated clockwise.
	 */
	struct {
		u16 lower;
		u16 upper;
	} range;

	/**
	 * @brief The start and stop position are the absolute values determining
	 * where the virtual encoder begins and ends on the physical encoder rotation.
	 * E.g if the start value is 0% and the stop value is 50% then the virtual
	 * encoder will only operate from 0 degrees to 180 degrees (midpoint) of the
	 * physical encoder.
	 *
	 * Note that the start and stop values are not percentages, they are a 16-bit
	 * value. To calculate percentages use the appropriate defines for
	 * min/max encoder value.
	 */
	struct {
		u16 start;
		u16 stop;
	} position;

	encoder_ctx_s*				 enc_ctx; // Pointer to encoder hardware context
	struct vencoder_ctx_s* next;		// Pointer to next virtual encoder in group
} vencoder_ctx_s;

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Prototypes ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

/**
 * @brief Initialises a single virtual encoder context.
 *
 * @param ctx Pointer to an virtual encoder context.
 * @param enc Pointer to hardware encoder context to map to the virtual enc.
 */
int vencoder_init(vencoder_ctx_s* ctx, encoder_ctx_s* enc);

/**
 * @brief Perform an update of a virtual encoder.
 * Should only be called if the underlying hardware encoder has been rotated.
 *
 * @param venc Pointer to a single virtual encoder context.
 */
void vencoder_update(vencoder_ctx_s* venc);
